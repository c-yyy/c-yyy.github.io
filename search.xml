<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019面试准备</title>
      <link href="/2019/01/02/2019-Interview/"/>
      <url>/2019/01/02/2019-Interview/</url>
      
        <content type="html"><![CDATA[<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><ul><li><p>JS基础</p><ul><li>变量类型<br>String、Number、Boolean、Object、null、undefined<br>Symbol(独一无二值,Symbol(‘a’))</li><li>作用域<br>执行上下文、自由变量的向上查找</li><li>this<br>指向最后调用的那个对象<br>箭头函数<br>call、apply、bind(传参不同)</li><li>原型<br><strong>proto</strong>指向其构造函数的prototype<br>instanceof判断一个函数是否是一个变量的构造函数</li><li>闭包<br>函数父级作用域在定义时非执行时<br>封装变量收敛修改权限，变量始终保存在内存中可供其他函数访问<br>做函数返回值、做函数参数传递</li><li>继承<br>原型链继承，类实例指向prototype<br>class类extends</li></ul></li><li><p>异步</p><ul><li>单线程</li><li>event-loop</li><li>jq-deferred -&gt; promise -&gt; async/await</li></ul></li><li><p>框架</p><ul><li>React<br>关注React16<br>fiber架构<br>Redux<br>Nextjs<br>RN</li><li>Vue<br>关注Vue3<br>Vuex<br>Nuxtjs<br>Weex</li><li>Angluar<br>关注Angluar7<br>模版@Input()、@Output()<br>ViewChild、ElementRef<br>rxjs</li></ul></li><li><p>小程序</p><ul><li>wepy</li><li>taro</li><li>小游戏引擎</li></ul></li><li><p>工具自动化</p><ul><li>git</li><li>rollup、webpack</li></ul></li><li><p>Nodejs</p></li><li><p>通讯</p><ul><li>HTTP2</li><li>hybrid</li></ul></li><li><p>HTML、CSS</p></li></ul><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><ul><li>简历</li><li>话术</li></ul>]]></content>
      
      
      <categories>
          
          <category> doc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React16-fiber</title>
      <link href="/2018/12/31/React16-fiber/"/>
      <url>/2018/12/31/React16-fiber/</url>
      
        <content type="html"><![CDATA[<h1 id="fiber是什么？"><a href="#fiber是什么？" class="headerlink" title="fiber是什么？"></a>fiber是什么？</h1><ul><li>React16中对diff算法的重构</li><li>由stack架构（递归调用阻塞线程）转为fiber架构</li></ul><h1 id="为什么fiber？"><a href="#为什么fiber？" class="headerlink" title="为什么fiber？"></a>为什么fiber？</h1><ul><li>横向对比stack架构</li><li>调度微任务，利用空闲期执行回调</li><li>使diff算法可控可追踪（达到非阻塞目的）</li></ul><h1 id="怎样实现fiber？"><a href="#怎样实现fiber？" class="headerlink" title="怎样实现fiber？"></a>怎样实现fiber？</h1><ul><li><p>纤维化（纤维队列）<br>我们需要将工作分成更小的部分，并使之能在短时间内运行，让主线程做更高优先级的事情<br>如果线程空闲，那么回到纤维队列</p></li><li><p>fiber对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let fiber = &#123;</span><br><span class="line">  tag: HOST_ROOT||HOST_COMPONENT||CLASS_COMPONENT,</span><br><span class="line">  type: &quot;div&quot;||Foo,</span><br><span class="line">  parent: parentFiber,</span><br><span class="line">  child: childFiber,</span><br><span class="line">  sibling: null,</span><br><span class="line">  alternate: currentFiber,</span><br><span class="line">  stateNode: document.createElement(&quot;div&quot;), // instance</span><br><span class="line">  props: &#123; children: [], className: &quot;foo&quot;&#125;,</span><br><span class="line">  partialState: null,</span><br><span class="line">  effectTag: PLACEMENT,</span><br><span class="line">  effects: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>window.requestIdleCallback()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const ENOUGH_TIME = 1 //毫秒ms</span><br><span class="line">let workQueue = [] // 纤维队列</span><br><span class="line">let nextUnitOfWork = null</span><br><span class="line"></span><br><span class="line">function schedule(task) &#123;</span><br><span class="line">  workQueue.push(task)</span><br><span class="line">  requestIdleCallback(performWork)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function performWork(deadline) &#123;</span><br><span class="line">  if(!nextUnitOfWork) &#123;</span><br><span class="line">    nextUnitOfWork = workQueue.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  while(nextUnitOfWork &amp;&amp; deadline.timeRemaining()&gt;ENOUGH_TIME) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork) // 执行当前work并返回下次work的所有信息</span><br><span class="line">  &#125;</span><br><span class="line">  if(nextUnitOfWork || workQueue.length &gt; 0) &#123;</span><br><span class="line">    requestIdleCallback(performWork)</span><br><span class="line">  &#125;</span><br><span class="line">  if(pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>纤维队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/ Fiber tags</span><br><span class="line">const HOST_COMPONENT = &quot;host&quot;</span><br><span class="line">const CLASS_COMPONENT = &quot;class&quot;</span><br><span class="line">const HOST_ROOT = &quot;root&quot;</span><br><span class="line"></span><br><span class="line">// Global state</span><br><span class="line">const updateQueue = [] // 存储等待更新</span><br><span class="line">let nextUnitOfWork = null</span><br><span class="line">let pendingCommit = null</span><br><span class="line"></span><br><span class="line">function render(elements, containerDom) &#123;</span><br><span class="line">  updateQueue.push(&#123;</span><br><span class="line">    from: HOST_ROOT,</span><br><span class="line">    dom: containerDom,</span><br><span class="line">    newProps: &#123; children: elements &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  requestIdleCallback(performWork)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function scheduleUpdate(instance, partialState) &#123;</span><br><span class="line">  updateQueue.push(&#123;</span><br><span class="line">    from: CLASS_COMPONENT,</span><br><span class="line">    instance: instance,</span><br><span class="line">    partialState: partialState</span><br><span class="line">  &#125;)</span><br><span class="line">  requestIdleCallback(performWork)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提问root节点作为第一帧如何转换成nextUnitOfWork<br>答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function resetNextUnitOfWork() &#123;</span><br><span class="line">  const update = updateQueue.shift();</span><br><span class="line">  if (!update) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将setState参数从更新有效内容复制到相应的光纤</span><br><span class="line">  if (update.partialState) &#123;</span><br><span class="line">    update.instance.__fiber.partialState = update.partialState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const root =</span><br><span class="line">    update.from == HOST_ROOT</span><br><span class="line">      ? update.dom._rootContainerFiber</span><br><span class="line">      : getRoot(update.instance.__fiber)</span><br><span class="line"></span><br><span class="line">  nextUnitOfWork = &#123;</span><br><span class="line">    tag: HOST_ROOT,</span><br><span class="line">    stateNode: update.dom || root.stateNode,</span><br><span class="line">    props: update.newProps || root.props,</span><br><span class="line">    alternate: root</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getRoot(fiber) &#123;</span><br><span class="line">  let node = fiber</span><br><span class="line">  while (node.parent) &#123;</span><br><span class="line">    node = node.parent</span><br><span class="line">  &#125;</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>提问如何构造后续帧并生成fiberTree🌲？<br>答案：<br><code>先处理叶子节点，然后是其兄弟节点，然后是双亲节点，从下往上遍历</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function performUnitOfWork(wipFiber) &#123;</span><br><span class="line">  beginWork(wipFiber)</span><br><span class="line">  if (wipFiber.child) &#123;</span><br><span class="line">    return wipFiber.child</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 遍历，直到没有child</span><br><span class="line">  let uow = wipFiber</span><br><span class="line">  while (uow) &#123;</span><br><span class="line">    completeWork(uow)</span><br><span class="line">    if (uow.sibling) &#123;</span><br><span class="line">      // Sibling needs to beginWork</span><br><span class="line">      return uow.sibling</span><br><span class="line">    &#125;</span><br><span class="line">    uow = uow.parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>fiber流程图<br><img src="../../public/img/fiber.png" alt="fiber流程图"></p></li><li><p>处理更新组件props和state</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function beginWork(wipFiber) &#123;</span><br><span class="line">  if (wipFiber.tag == CLASS_COMPONENT) &#123;</span><br><span class="line">    updateClassComponent(wipFiber);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    updateHostComponent(wipFiber);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateHostComponent(wipFiber) &#123;</span><br><span class="line">  if (!wipFiber.stateNode) &#123;</span><br><span class="line">    wipFiber.stateNode = createDomElement(wipFiber);</span><br><span class="line">  &#125;</span><br><span class="line">  const newChildElements = wipFiber.props.children;</span><br><span class="line">  reconcileChildrenArray(wipFiber, newChildElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateClassComponent(wipFiber) &#123;</span><br><span class="line">  let instance = wipFiber.stateNode;</span><br><span class="line">  if (instance == null) &#123;</span><br><span class="line">    // Call class constructor</span><br><span class="line">    instance = wipFiber.stateNode = createInstance(wipFiber);</span><br><span class="line">  &#125; else if (wipFiber.props == instance.props &amp;&amp; !wipFiber.partialState) &#123;</span><br><span class="line">    // No need to render, clone children from last time</span><br><span class="line">    cloneChildFibers(wipFiber);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  instance.props = wipFiber.props;</span><br><span class="line">  instance.state = Object.assign(&#123;&#125;, instance.state, wipFiber.partialState);</span><br><span class="line">  wipFiber.partialState = null;</span><br><span class="line"></span><br><span class="line">  const newChildElements = wipFiber.stateNode.render();</span><br><span class="line">  reconcileChildrenArray(wipFiber, newChildElements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始diff，将oldFiber与elements做对比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// Effect tags</span><br><span class="line">const PLACEMENT = 1;</span><br><span class="line">const DELETION = 2;</span><br><span class="line">const UPDATE = 3;</span><br><span class="line"></span><br><span class="line">function arrify(val) &#123;</span><br><span class="line">  return val == null ? [] : Array.isArray(val) ? val : [val];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reconcileChildrenArray(wipFiber, newChildElements) &#123;</span><br><span class="line">  const elements = arrify(newChildElements);</span><br><span class="line"></span><br><span class="line">  let index = 0;</span><br><span class="line">  let oldFiber = wipFiber.alternate ? wipFiber.alternate.child : null;</span><br><span class="line">  let newFiber = null;</span><br><span class="line">  while (index &lt; elements.length || oldFiber != null) &#123;</span><br><span class="line">    const prevFiber = newFiber;</span><br><span class="line">    const element = index &lt; elements.length &amp;&amp; elements[index];</span><br><span class="line">    const sameType = oldFiber &amp;&amp; element &amp;&amp; element.type == oldFiber.type;</span><br><span class="line"></span><br><span class="line">    if (sameType) &#123;</span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        type: oldFiber.type,</span><br><span class="line">        tag: oldFiber.tag,</span><br><span class="line">        stateNode: oldFiber.stateNode,</span><br><span class="line">        props: element.props,</span><br><span class="line">        parent: wipFiber,</span><br><span class="line">        alternate: oldFiber,</span><br><span class="line">        partialState: oldFiber.partialState,</span><br><span class="line">        effectTag: UPDATE</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        type: element.type,</span><br><span class="line">        tag:</span><br><span class="line">          typeof element.type === &quot;string&quot; ? HOST_COMPONENT : CLASS_COMPONENT,</span><br><span class="line">        props: element.props,</span><br><span class="line">        parent: wipFiber,</span><br><span class="line">        effectTag: PLACEMENT</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">      oldFiber.effectTag = DELETION;</span><br><span class="line">      wipFiber.effects = wipFiber.effects || [];</span><br><span class="line">      wipFiber.effects.push(oldFiber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (oldFiber) &#123;</span><br><span class="line">      oldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (index == 0) &#123;</span><br><span class="line">      wipFiber.child = newFiber;</span><br><span class="line">    &#125; else if (prevFiber &amp;&amp; element) &#123;</span><br><span class="line">      prevFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后一步，更新到dom</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function commitAllWork(fiber) &#123;</span><br><span class="line">  fiber.effects.forEach(f =&gt; &#123;</span><br><span class="line">    commitWork(f);</span><br><span class="line">  &#125;);</span><br><span class="line">  fiber.stateNode._rootContainerFiber = fiber;</span><br><span class="line">  nextUnitOfWork = null;</span><br><span class="line">  pendingCommit = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function commitWork(fiber) &#123;</span><br><span class="line">  if (fiber.tag == HOST_ROOT) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let domParentFiber = fiber.parent;</span><br><span class="line">  while (domParentFiber.tag == CLASS_COMPONENT) &#123;</span><br><span class="line">    domParentFiber = domParentFiber.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  const domParent = domParentFiber.stateNode;</span><br><span class="line"></span><br><span class="line">  if (fiber.effectTag == PLACEMENT &amp;&amp; fiber.tag == HOST_COMPONENT) &#123;</span><br><span class="line">    domParent.appendChild(fiber.stateNode);</span><br><span class="line">  &#125; else if (fiber.effectTag == UPDATE) &#123;</span><br><span class="line">    updateDomProperties(fiber.stateNode, fiber.alternate.props, fiber.props);</span><br><span class="line">  &#125; else if (fiber.effectTag == DELETION) &#123;</span><br><span class="line">    commitDeletion(fiber, domParent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function commitDeletion(fiber, domParent) &#123;</span><br><span class="line">  let node = fiber;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (node.tag == CLASS_COMPONENT) &#123;</span><br><span class="line">      node = node.child;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    domParent.removeChild(node.stateNode);</span><br><span class="line">    while (node != fiber &amp;&amp; !node.sibling) &#123;</span><br><span class="line">      node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    if (node == fiber) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    node = node.sibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写一个精简版React</title>
      <link href="/2018/12/30/React-stack/"/>
      <url>/2018/12/30/React-stack/</url>
      
        <content type="html"><![CDATA[<h1 id="先贴原文，respect！以下是总结思考"><a href="#先贴原文，respect！以下是总结思考" class="headerlink" title="先贴原文，respect！以下是总结思考"></a>先贴原文，respect！以下是总结思考</h1><p><a href="https://juejin.im/post/5c0c7304f265da613e22106c?utm_source=gold_browser_extension" target="_blank" rel="noopener">200行代码实现简版react</a></p><hr><h1 id="React-Component-jsx-vdom"><a href="#React-Component-jsx-vdom" class="headerlink" title="React = Component + jsx + vdom"></a>React = Component + jsx + vdom</h1><ul><li><p>Component = (class component) + (functional component)</p><h2 id="element（typeof-type-’string’-’dom节点’-’组件实例’）"><a href="#element（typeof-type-’string’-’dom节点’-’组件实例’）" class="headerlink" title="element（typeof type=’string’?’dom节点’:’组件实例’）"></a>element<object>（typeof type=’string’?’dom节点’:’组件实例’）</object></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Button(props) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: &apos;button&apos;||Button</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: &apos;button button-blue&apos;,</span><br><span class="line">    children: &#123;</span><br><span class="line">      type: &apos;button-children&apos;,</span><br><span class="line">      props: &#123;</span><br><span class="line">        children: &apos;nb!&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提问：React如何将jsx语法转换为纯对象？<br>答案：组件类返回值经过Babel（DiyReact.createElement）<br>输出<code>var foo = createElement(&#39;div&#39;,{id:&#39;foo&#39;},&#39;nb!&#39;);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 转换为element对象</span><br><span class="line">function createElement(type, props, ...children) &#123;</span><br><span class="line">  props = Object.assign(&#123;&#125;,props);</span><br><span class="line">  props.children = [].concat(...children)</span><br><span class="line">    .filter(child =&gt; child != null &amp;&amp; child !== false)</span><br><span class="line">    .map(child =&gt; child instanceof Object ? child : createTextElement(child))</span><br><span class="line">  return &#123;type, props&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="element-amp-amp-dom"><a href="#element-amp-amp-dom" class="headerlink" title="element &amp;&amp; dom"></a>element &amp;&amp; dom</h2><p><img src="https://user-gold-cdn.xitu.io/2018/12/9/16790a131646f2ad?imageView2/0/w/1280/h/960/ignore-error/1" alt="dom"></p></li><li><p>ViewModel = vdomTree + diffAlgori</p><h2 id="vdomTree"><a href="#vdomTree" class="headerlink" title="vdomTree"></a>vdomTree</h2><p>creatElement()函数最终输出一个对象，那我们可以对其中的props或者state进行监听与更新（观察者模式）<br>整个页面对应一颗可以实时更新状态的虚拟dom节点树🌲</p><h2 id="diffAlgori（避免删除重建dom节点的开销）"><a href="#diffAlgori（避免删除重建dom节点的开销）" class="headerlink" title="diffAlgori（避免删除重建dom节点的开销）"></a>diffAlgori（避免删除重建dom节点的开销）</h2><p><img src="https://user-gold-cdn.xitu.io/2018/12/9/16790a13163a4fa7?imageView2/0/w/1280/h/960/ignore-error/1" alt="diff算法"></p></li><li><p>ReactDOM.render()<br>react入口即是第一帧，所以此后的帧只会在挂载期diff<br>如：compentDidMount、componentWillUnmount</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// rootInstance用来缓存一帧vdom</span><br><span class="line">let rootInstance = null，这里即是第一帧</span><br><span class="line">function render(element, parentDom) &#123;</span><br><span class="line">  // prevInstance指向前一帧</span><br><span class="line">  const prevInstance = rootInstance // 这里实现的仅是ReactDOM.render,非组件render</span><br><span class="line">  // element参数指向新生成的vdomTree</span><br><span class="line">  const nextInstance = reconcile(parentDom, prevInstance, element) // 对比前后帧</span><br><span class="line">  // 调用完reconcile算法（即diff算法）后将rootInstance指向最新一帧</span><br><span class="line">  rootInstance = nextInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提问：你这里用instance表示帧，那跟前面的element有什么关系？<br>答案：instance = element + dom<br>在对比前后帧调用reconcile()进行diff比较时需要更新应用到真实dom<br>由此还需要实现一个instantiate函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function instantiate(element) &#123;</span><br><span class="line">  const &#123;type, props=&#123;&#125;&#125; = element</span><br><span class="line">  const isDomElement = typeof type === &apos;string&apos;</span><br><span class="line">  // 区分函数式组件与类组件</span><br><span class="line">  const isClassElement = !!(type.prototype &amp;&amp; type.prototype.isReactComponent)</span><br><span class="line">  if(isDomElement) &#123;</span><br><span class="line">    // 创建dom</span><br><span class="line">    const isTextElement = type === TEXT_ELEMENT</span><br><span class="line">    const dom = isTextElement ?</span><br><span class="line">    document.createTextNode(&apos;&apos;) :</span><br><span class="line">    document.createElement(type)</span><br><span class="line">    // 设置dom属性，绑定dom事件</span><br><span class="line">    updateDomProperties(dom, [], element.props)</span><br><span class="line">    const children = props.children || []</span><br><span class="line">    const childInstances = children.map(instantiate) // 子节点递归</span><br><span class="line">    const childDoms = childInstances.map(childInstance =&gt; childInstance.dom)</span><br><span class="line">    childDoms.forEach(childDom =&gt; dom.appendChild(childDom))</span><br><span class="line">    const instance = &#123;element, dom, childInstances&#125;</span><br><span class="line">    return instance</span><br><span class="line">  &#125; else if(isClassElement) &#123;</span><br><span class="line">    const instance = &#123;&#125;</span><br><span class="line">    const publicInstance = createPublicInstance(element, instance)</span><br><span class="line">    const childElement = publicInstance.render()</span><br><span class="line">    const childInstance = instantiate(childElement) // 子节点递归</span><br><span class="line">    Object.assign(instance, &#123;dom: childInstance.dom, element, childInstance, publicInstance&#125;)</span><br><span class="line">    reuturn instance</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const childElement = type(element.props)</span><br><span class="line">    const childInstance = instantiate(childElement) // 子节点递归</span><br><span class="line">    const instance = &#123;</span><br><span class="line">      dom: childInstance.dom,</span><br><span class="line">      element,</span><br><span class="line">      childInstance</span><br><span class="line">    &#125;</span><br><span class="line">    return instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>提问：你说这么多我也不想看啊，最核心的对比前后帧是怎么实现的呢？<br>答案：reconcile()<br><code>由stack算法（递归实现，阻塞线程）升级为React16中fiber架构（requestIdleCallback）</code><br><img src="https://user-gold-cdn.xitu.io/2018/12/9/16790a13163656b3?imageView2/0/w/1280/h/960/ignore-error/1" alt="reconcile"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">  function reconcile(parentDom, instance, element) &#123;</span><br><span class="line">  if (instance === null) &#123;</span><br><span class="line">    const newInstance = instantiate(element);</span><br><span class="line">    // componentWillMount</span><br><span class="line">    newInstance.publicInstance</span><br><span class="line">      &amp;&amp; newInstance.publicInstance.componentWillMount</span><br><span class="line">      &amp;&amp; newInstance.publicInstance.componentWillMount();</span><br><span class="line">    parentDom.appendChild(newInstance.dom);</span><br><span class="line">    // componentDidMount</span><br><span class="line">    newInstance.publicInstance</span><br><span class="line">      &amp;&amp; newInstance.publicInstance.componentDidMount</span><br><span class="line">      &amp;&amp; newInstance.publicInstance.componentDidMount();</span><br><span class="line">    return newInstance;</span><br><span class="line">  &#125; else if (element === null) &#123;</span><br><span class="line">    // componentWillUnmount</span><br><span class="line">    instance.publicInstance</span><br><span class="line">      &amp;&amp; instance.publicInstance.componentWillUnmount</span><br><span class="line">      &amp;&amp; instance.publicInstance.componentWillUnmount();</span><br><span class="line">    parentDom.removeChild(instance.dom);</span><br><span class="line">    return null;</span><br><span class="line">  &#125; else if (instance.element.type !== element.type) &#123;</span><br><span class="line">    const newInstance = instantiate(element);</span><br><span class="line">    // componentDidMount</span><br><span class="line">    newInstance.publicInstance</span><br><span class="line">      &amp;&amp; newInstance.publicInstance.componentDidMount</span><br><span class="line">      &amp;&amp; newInstance.publicInstance.componentDidMount();</span><br><span class="line">    parentDom.replaceChild(newInstance.dom, instance.dom);</span><br><span class="line">    return newInstance;</span><br><span class="line">  &#125; else if (typeof element.type === &apos;string&apos;) &#123;</span><br><span class="line">    updateDomProperties(instance.dom, instance.element.props, element.props);</span><br><span class="line">    instance.childInstances = reconcileChildren(instance, element);</span><br><span class="line">    instance.element = element;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (instance.publicInstance</span><br><span class="line">      &amp;&amp; instance.publicInstance.shouldcomponentUpdate) &#123;</span><br><span class="line">      if (!instance.publicInstance.shouldcomponentUpdate()) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // componentWillUpdate</span><br><span class="line">    instance.publicInstance</span><br><span class="line">      &amp;&amp; instance.publicInstance.componentWillUpdate</span><br><span class="line">      &amp;&amp; instance.publicInstance.componentWillUpdate();</span><br><span class="line">    instance.publicInstance.props = element.props;</span><br><span class="line">    const newChildElement = instance.publicInstance.render();</span><br><span class="line">    const oldChildInstance = instance.childInstance;</span><br><span class="line">    const newChildInstance = reconcile(parentDom, oldChildInstance, newChildElement);</span><br><span class="line">    // componentDidUpdate</span><br><span class="line">    instance.publicInstance</span><br><span class="line">      &amp;&amp; instance.publicInstance.componentDidUpdate</span><br><span class="line">      &amp;&amp; instance.publicInstance.componentDidUpdate();</span><br><span class="line">    instance.dom = newChildInstance.dom;</span><br><span class="line">    instance.childInstance = newChildInstance;</span><br><span class="line">    instance.element = element;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reconcileChildren(instance, element) &#123;</span><br><span class="line">  const &#123; dom, childInstances &#125; = instance;</span><br><span class="line">  const newChildElements = element.props.children || [];</span><br><span class="line">  const count = Math.max(childInstances.length, newChildElements.length);</span><br><span class="line">  const newChildInstances = [];</span><br><span class="line">  for (let i = 0; i &lt; count; i++) &#123;</span><br><span class="line">    newChildInstances[i] = reconcile(dom, childInstances[i], newChildElements[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return newChildInstances.filter(instance =&gt; instance !== null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于团队</title>
      <link href="/2018/12/29/team/"/>
      <url>/2018/12/29/team/</url>
      
        <content type="html"><![CDATA[<h1 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h1><ul><li><p>目标量化<br>对于新需求的把控，需要leader考虑、细化每一个重要的点，kpi是多少，合理分配到研发层，<br>具体实现交给研发，项目排期具问具分，对于前端团队来讲，可以从页面转换率入手，建立订单<br>漏斗模型，做性能分析优化，UI交互优化，每一个具体的层面都需要转化目标</p></li><li><p>解决问题<br>团队配合中，可能会出现kpi未完成，无休止加班，高压迭代，导致一次迭代战线拉长，出现疲惫，<br>效率降低，容易犯错，又如何帮助新人快速融入团队，上手项目。</p><p>思考团队制定的从产品-&gt;设计-&gt;开发-&gt;测试-&gt;上线这一套流程是否为当前最适合流程，及时做出<br>调整，对于公共服务与工具化、自动化服务等，有没有内部一套完整的解决方案。</p></li></ul><h1 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h1><ul><li><p>意识<br>做业务之前，是否对项目整体有全局意识，是否能分清主次，对于团队内的每一个流程是否有亲自参与，<br>沟通方面是否能表达到位，知道自己在团队中的担当位置，透过现象看本质，当有问题后有没有深入了解<br>过框架背后的原理，或者架构方面出了什么问题</p></li><li><p>技术<br>良莠不齐的同事如何相处与沟通，如何提升自己的开发效率，在面对某些问题有成熟的解决方案，并且能<br>有条理、清晰的阐述给同事，是否可以做一些工具类或者UI库等的东西来帮助团队改善重复劳动的状况，<br>如何组织内部分享，提升团队综合技术能力</p></li></ul><h1 id="公共管理"><a href="#公共管理" class="headerlink" title="公共管理"></a>公共管理</h1><ul><li>团队工具化程度与成熟度正相关</li><li>最优与最合适解决方案</li><li>协作成本与执行力</li><li>是否有feedback(反馈机制)</li></ul>]]></content>
      
      
      <categories>
          
          <category> doc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2018/12/29/cors/"/>
      <url>/2018/12/29/cors/</url>
      
        <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><ul><li>协议+域名+端口 都相同</li><li>限制Cookie、localStorage、IndexDB、Ajax</li></ul><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul><li>通过jsonp跨域</li><li>document.domain + iframe跨域</li><li>location.hash + iframe</li><li>window.name + iframe跨域</li><li>postMessage跨域</li><li>跨域资源共享（CORS）</li><li>nginx代理跨域</li><li>nodejs中间件代理跨域</li><li>WebSocket协议跨域</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>CORS为主流解决方案</li><li>反向代理的配置与使用nodejs中间件原理类似</li><li>各方案优缺点</li></ul>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客说明</title>
      <link href="/2018/12/28/introduce/"/>
      <url>/2018/12/28/introduce/</url>
      
        <content type="html"><![CDATA[<h1 id="关于我的博客"><a href="#关于我的博客" class="headerlink" title="关于我的博客"></a>关于我的博客</h1><ul><li>做了改版</li><li>技术和生活都会记录下来</li><li>输出干货</li></ul><h1 id="关于主题"><a href="#关于主题" class="headerlink" title="关于主题"></a>关于主题</h1><ul><li>Freemind(<a href="https://github.com/blackshow/hexo-theme-freemind.386" target="_blank" rel="noopener">https://github.com/blackshow/hexo-theme-freemind.386</a>)</li><li>so cool!</li></ul><h1 id="纪念"><a href="#纪念" class="headerlink" title="纪念"></a>纪念</h1><ul><li>今天也是第一份工作离职</li></ul>]]></content>
      
      
      <categories>
          
          <category> doc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
